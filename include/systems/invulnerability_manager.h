#pragma once
#include <memory>
#include <vector>

#include "../components/components.h"
#include "../game_state.h"
#include "../helper/ecs.h"
#include "../helper/vec2d.h"

class InvurelnabilityManagerSystem : public System
{
public:
    InvurelnabilityManagerSystem(std::vector<std::shared_ptr<Entity>>* entities)
      : m_entities(entities){};

    void Update(double dt) override
    {
        for (auto entity : *m_entities)
        {

            CollidedComponent* collided_component = entity->GetComponent<CollidedComponent>();
            SquareRenderComponent* square_render_component
              = entity->GetComponent<SquareRenderComponent>();

            if (collided_component == nullptr)
            {
                continue;
            }

            InvulnerabilityComponent* invulnerability_component
              = entity->GetComponent<InvulnerabilityComponent>();

            // Add invulnerability component if not existed
            if (invulnerability_component == nullptr)
            {
                std::shared_ptr<InvulnerabilityComponent> invulnerability_component_shared_pr
                  = std::make_shared<InvulnerabilityComponent>(*entity, 1000);

                entity->AddComponent(invulnerability_component_shared_pr);
                invulnerability_component = invulnerability_component_shared_pr.get();
            }

            // check if invulnerability are over and removes then
            for (auto invulnerable_element
                 = invulnerability_component->invulnerabilities_map.begin();
                 invulnerable_element != invulnerability_component->invulnerabilities_map.end();)
            {

                std::chrono::time_point<std::chrono::steady_clock> invunerable_since
                  = invulnerable_element->second;
                auto now = std::chrono::steady_clock::now();
                if (std::chrono::duration_cast<std::chrono::milliseconds>(now - invunerable_since)
                      .count()
                    > invulnerability_component->invulnerability_duration_ms)
                {
                    if (square_render_component != nullptr)
                    {
                        auto& color = square_render_component->color;
                        color.alpha = 255;
                        square_render_component->color = color;
                    }

                    // remove invulnerability
                    invulnerable_element = invulnerability_component->invulnerabilities_map.erase(
                      invulnerable_element);

                    // TODO: better this
                    if (invulnerability_component->invulnerabilities_map.size() <= 0)
                    {
                        break;
                    }
                }
                else
                {
                    ++invulnerable_element;
                }
            }

            // for each collision..
            //    check if no invulnerability -> create it + remove colission
            //    existing invulnerability -> if time not surpassed duration + remove colission
            //    existing invulnerability -> if time surpassed, remove invulnerability
            for (int ite(0); ite < collided_component->entities_collided_with.size(); ite++)
            {
                auto entitiy_collided_with = collided_component->entities_collided_with[ite];

                // check if invulnerability does not exist-> add new invulnerability + remove
                // colission
                if (invulnerability_component->invulnerabilities_map.find(
                      entitiy_collided_with->id())
                    == invulnerability_component->invulnerabilities_map.end())
                {
                    if (square_render_component != nullptr)
                    {
                        auto& color = square_render_component->color;
                        color.alpha /= 2;
                        square_render_component->color = color;
                    }

                    // add new invulnerability
                    invulnerability_component->invulnerabilities_map.insert(
                      { entitiy_collided_with->id(), std::chrono::steady_clock::now() });
                }
            }
        }
    }

private:
    std::vector<std::shared_ptr<Entity>>* m_entities;
};
